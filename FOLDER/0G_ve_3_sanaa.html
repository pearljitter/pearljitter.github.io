<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>pearljitter</title>
  <script type="text/javascript" src="js/processing.js"></script>
  <link rel="stylesheet" href="pageStyle.css">
  <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans&display=swap" rel="stylesheet">
  <style>
    body {
      background-color: rgb(0, 0, 0);
    }
  </style>
</head>

<body>
  <div class="decontainer">
    <div class="moveback-link">
      <a href="0G_10_virtualEssence.html" class="btn">BACK</a>
    </div>
  </div>

  <div>
    <script type="text/processing">
            int cnt=90;
            float mult=0.8;
            
            int cVal[][]=new int[cnt][cnt];  //cell value
            int aVal[][]=new int[cnt][cnt];  //aura value
            int nVal[][]=new int[cnt][cnt];  //new wall value
            
            int gap=2; //circle aura  offset gap
            
            int mex=int(cnt/2);
            int mey=int(cnt/2);
            
            
            int bullx[]=new int[30];
            int bully[]=new int[30];
            int bullvec[]=new int[30];
            int currBull=0;
            int bullsp=1;
            int bullcol=-1;
            
            int encnt=40;
            int enx[]={34, 28, 39, 50, 29, 56, 71, 64, 60, 59, 40, 53, 46, 65, 41, 40, 33, 29, 30, 33, 25, 24, 20, 17, 16, 34, 16, 22, 23, 23, 44, 20, 25, 29, 65, 29, 17, 67, 69, 47, 30, 39, 45, 56, 59, 61, 63, 64, 59, 58, 73, 68, 45, 68, 59, 67, 32, 41, 42, 52, 48, 21, 70, 75, 64, 41, 23, 24, 21, 56, 29, 47, 43, 29, 34, 47, 47, 35, 39, 53
            };
            int eny[]={68, 73, 67, 75, 70, 65, 69, 66, 70, 60, 53, 70, 51, 25, 48, 39, 37, 43, 47, 41, 32, 25, 21, 26, 46, 56, 63, 61, 71, 66, 34, 29, 56, 28, 21, 25, 16, 33, 57, 56, 21, 31, 37, 56, 43, 45, 46, 38, 38, 50, 44, 17, 16, 28, 29, 23, 32, 29, 25, 33, 30, 34, 33, 28, 61, 43, 44, 41, 43, 34, 51, 62, 52, 66, 64, 65, 70, 61, 20, 21
            };
            int tenx[]=new int[cnt];
            int teny[]=new int[cnt];
            int envec[]=new int[cnt];
            int ensp[]=new int[cnt];
            int enliv[]=new int[cnt];
            
            int gblocked=0;
            
            int dialRad=200;
            int dialX=900+(1200-900)/2;
            int dialY=900-+(1200-900)/2;
            int dialMode=0;
            int dicol;
            float angle=0;
            
            
            void setup() {
              background(200);
              size(1200, 900);
              frameRate(30);
              textAlign(CENTER, CENTER);
              for (int i=0; i<30; i++) {
                bullvec[i]=-1;
              }
              for (int i=0; i<encnt; i++) {
                envec[i]=int(random(0, 3));
                ensp[i]=1;
                enliv[i]=2;
                tenx[i]=enx[i];
                teny[i]=eny[i];
              }
            
              //////background------------------------------------------------------------------
            
              for (int i=15; i>0; i--) {
                stroke(150+i*3);
                strokeWeight(i);
                line(height, 0, height, height);
              }
              stroke(130);
              line(height, 0, height, height);
              noStroke();
              //////set cell value------------------------------------------------------------------
            
              ///////////horizontal
              // 조건을 열(j)에 따라 그룹화
              int[][] rows = {
                {18, 36, 27},
                {18, 30, 36},
                {18, 30, 45},
                {33, 36, 45},
                {18, 21, 54},
                {24, 30, 54},
                {18, 21, 63},
                {24, 30, 63},
                {24, 30, 72},
                {33, 48, 54},
                {51, 57, 54},
                {60, 66, 54},
                {69, 72, 54},
                {51, 57, 63},
                {60, 66, 63},
                {69, 72, 63},
                {51, 57, 72},
                {60, 66, 72},
                {54, 66, 27},
                {69, 72, 27},
                {69, 72, 36},
                {33, 48, 36},
                {51, 57, 36},
                {60, 66, 36},
                {33, 48, 18},
                {51, 56, 18},
                {33, 39, 72},
                {42, 48, 72},
                {33, 41, 63},
                {43, 48, 63},
                {24, 39, 14},
                {42, 48, 14},
                {51, 66, 14},
                {61, 66, 76},
                {42, 57, 76},
                {24, 38, 76},
                {18, 20, 50},
                {25, 27, 50},
                {18, 21, 72},
                {69, 72, 72},
                {18, 30, 18},
                {58, 72, 18},
                {14, 20, 14},
                {70, 76, 14},
                {14, 20, 76},
                {70, 76, 76},
              };
            
              // 반복문으로 cVal 채우기
              for (int k = 0; k < rows.length; ++k) {
                int startRow = rows[k][0];
                int endRow = rows[k][1];
                int col = rows[k][2];
                for (int n = startRow; n < endRow; n++) {
                  cVal[n][col] = 1;
                }
              }
            
              /////////////vertical
              int[][] column = {
                {27, 18, 21},
                {36, 18, 21},
                {36, 24, 30},
                {27, 24, 30},
                {18, 24, 30},
                {18, 33, 39},
                {27, 33, 39},
                {36, 33, 39},
                {36, 51, 72},
                {36, 42, 48},
                {27, 60, 72},
                {27, 54, 57},
                {18, 54, 57},
                {63, 60, 72},
                {63, 54, 57},
                {72, 42, 57},
                {72, 33, 39},
                {54, 42, 57},
                {54, 33, 39},
                {54, 18, 30},
                {63, 33, 36},
                {63, 18, 30},
                {72, 24, 30},
                {45, 54, 66},
                {45, 69, 72},
                {54, 69, 72},
                {54, 60, 66},
                {14, 24, 29},
                {14, 33, 39},
                {76, 24, 29},
                {76, 33, 39},
                {76, 42, 48},
                {76, 51, 66},
                {18, 42, 50},
                {27, 42, 51},
                {39, 54, 61},
                {60, 20, 27},
                {18, 60, 72},
                {72, 60, 73},
                {18, 18, 21},
                {72, 18, 21},
                {14, 14, 20},
                {76, 14, 20},
                {14, 42, 77},
                {76, 70, 77},
              };
              // 반복문으로 cVal 채우기
              for (int k = 0; k < column.length; ++k) {
                int startColumn = column[k][1];
                int endColumn = column[k][2];
                int ro = column[k][0];
                for (int n = startColumn; n < endColumn; n++) {
                  cVal[ro][n] = 1;
                }
              }
            
              ///////---------------------------------------------------------------------
            }
            
            void draw() {
            
              //background(0);
              textSize(10);
              //---------------------------
            
              fill(220, 30);
              noStroke();
              rect(height/cnt, height/cnt, height*(cnt-2)/cnt, height*(cnt-2)/cnt);
            
              //----------------------------------------------------------------------------------------
              drawWall();
              control();
              shoot();
              bullmove();
              enmove();
              dial();
            }
            
            void drawWall() {
            
              for (int i=1; i<cnt-1; i++) {
                for (int j=1; j<cnt-1; j++) {
            
                  rectMode(CORNER);
                  if (cVal[i][j]==1) {
                    fill(70);
                    rect(i*height/cnt, j*height/cnt, mult*height/cnt, mult*height/cnt);
                  }
                  noStroke();
                  if (aVal[i][j]==1) { //draw aura cell
                    fill(255, 50, 50, 10);
                    rect(i*height/cnt, j*height/cnt, mult*height/cnt, mult*height/cnt);
                  }
                  if (nVal[i][j]==1) {  //draw damaged wall cell
                    fill(0, 0, 255);
                    rect(i*height/cnt, j*height/cnt, mult*height/cnt, mult*height/cnt);
                  }
                }
              }
            }
            
            void control() {
              int blocked=0;
              int pmex, pmey;
              pmex=mex;
              pmey=mey;
              if (frameCount%2==0) {
                if (dialMode==1) {
                  mey=max(1, mey-1);
                } else if (dialMode==3) {
                  mey=min(cnt-2, mey+1);
                } else if (dialMode==2) {
                  mex=max(1, mex-1);
                } else if (dialMode==0) {
                  mex=min(cnt-2, mex+1);
                }
              }
            
              //wall constraint------------------------------
              if (cVal[mex][mey]==1) {
                mex=pmex;
                mey=pmey;
              }
              //draw me--------------------------------------------------------------
              fill(255, 0, 0);
              rect(mex*height/cnt, mey*height/cnt, mult*height/cnt, mult*height/cnt);
            
              //draw aura-----------------------------------------------
              for (int i=1; i<cnt-1; i++) {
                for (int j=1; j<cnt-1; j++) {
                  aVal[i][j]=0;
                }
              }
            
              for (int n=1; n<cnt-2; n++) {
                for (int i=max(1, mex-n); i<=min(cnt-2, mex+n); i++) {
                  for (int j=max(1, mey-n); j<=min(cnt-2, mey+n); j++) {
                    if (blocked ==0 && int(dist(i, j, mex, mey))==n && cVal[i][j]==1) {
                      blocked=n;
                    }
                  }
                }
              }
              gblocked=blocked;
              for (int num=1; num*gap <blocked; num++) {
                for (int i=max(1, mex-num*gap); i<=min(cnt-2, mex+num*gap); i++) {
                  for (int j=max(1, mey-num*gap); j<=min(cnt-2, mey+num*gap); j++) {
                    if (int(dist(i, j, mex, mey))==num*gap) {
                      aVal[i][j]=1;
                    }
                  }
                }
              }
            
              /////////////
            }
            
            void shoot() {
            
              if (mousePressed==true && mouseButton==RIGHT) {
                bullcol=1;
                dicol=bullcol;
                for (int i=0; i<4; i++) {
                  currBull=(currBull+1)%30;
                  bullvec[currBull]=i;
                  bullx[currBull]=mex;
                  bully[currBull]=mey;
                }
              } else {
                dicol=-1;
              }
            }
            
            void bullmove() {
              for (int i=0; i<30; i++) {
                if (bullvec[i]>-1) {
            
                  fill(155+bullcol*100, 0, 255-bullcol*100);
                  rect(bullx[i]*height/cnt, bully[i]*height/cnt, mult*height/cnt, mult*height/cnt);
            
                  if (bullvec[i]==0) {
                    bullx[i]=bullx[i]+bullsp;
                  } else if (bullvec[i]==1) {
                    bully[i]=bully[i]-bullsp;
                  } else if (bullvec[i]==2) {
                    bullx[i]=bullx[i]-bullsp;
                  } else if (bullvec[i]==3) {
                    bully[i]=bully[i]+bullsp;
                  }
                  if (cVal[bullx[i]][bully[i]]==1 || bullx[i]<2 || bullx[i]>cnt-3 || bully[i]<2 || bully[i]>cnt-3 ) {
                    bullvec[i]=-1;
                  }
            
                  if (cVal[bullx[i]][bully[i]]==1) {
                    nVal[bullx[i]][bully[i]]=1;
                  }
                  //check shot or not
                  for (int j=0; j<encnt; j++) {
                    if (dist(bullx[i], bully[i], enx[j], eny[j])<3) {
                      enliv[j]=1;
                    }
                  }
                } else {
                  bullx[i]=0;
                  bully[i]=0;
                }
              }
            }
            
            void enmove() {
              for (int i=0; i<encnt; i++) {
                if (enliv[i]>0) {
                  if (enliv[i]==2) {
                    if (frameCount%3==1) {
                      if (envec[i]==0) {
                        teny[i]=eny[i]-ensp[i];
                      } else if (envec[i]==1) {
                        tenx[i]= enx[i]+ensp[i];
                      } else if (envec[i]==2) {
                        teny[i]=eny[i]+ensp[i];
                      } else if (envec[i]==3) {
                        tenx[i]= enx[i]-ensp[i];
                      }
            
                      if (cVal[tenx[i]][teny[i]]!=1 && tenx[i]>1 && tenx[i]<cnt-1  && teny[i]>1 && teny[i]<cnt-1) {
                        enx[i]=tenx[i];
                        eny[i]=teny[i];
                      } else {
                        ensp[i]=ensp[i]*(-1);
                      }
                    }
                  }
                  if (enliv[i]==1 && dist(mex, mey, enx[i], eny[i])<gblocked) {
                    enliv[i]=0;
                  }
            
                  //draw enemy--------------------------------------------------------------
                  fill(0,120+70*(enliv[i]-1), 0, 190);
                  rect(enx[i]*height/cnt, eny[i]*height/cnt, mult*height/cnt, mult*height/cnt);
                }
              }
            }
            
            void dial() {
              if (mousePressed && dist(dialX, dialY, mouseX, mouseY) < dialRad/2 &&  dist(dialX, dialY, mouseX, mouseY)>25) {
                if (mouseButton==LEFT) {
                  dicol=0;
                }
                if (mouseX>=dialX) {
                  angle=asin((mouseY-dialY)/max(1, dist(dialX, dialY, mouseX, mouseY)));
                } else {
                  angle=PI-asin((mouseY-dialY)/max(1, dist(dialX, dialY, mouseX, mouseY)));
                }
            
                if (mouseX>=dialX && angle>=-PI/4 && angle<PI/4) {
                  dialMode=0;
                } else if ((mouseX>=dialX && angle>=PI/4) || (mouseX<dialX && angle<PI*3/4)) {
                  dialMode=3;
                } else if (mouseX<dialX && angle>=PI*3/4 && angle<PI*5/4) {
                  dialMode=2;
                } else {
                  dialMode=1;
                }
              } else {
                dialMode=-1;
              }
            
            
              fill(10);
              ellipse(dialX, dialY, dialRad, dialRad);
              fill(120);
              ellipse(dialX, dialY, dialRad*0.98, dialRad*0.98);
              fill(10);
              ellipse(dialX, dialY, dialRad*0.96, dialRad*0.96);
              fill(180);
              ellipse(dialX, dialY, dialRad*0.8, dialRad*0.8);
            
              for (int i=15; i>0; i--) {
                fill(120+i*4);
                ellipse(dialX, dialY, dialRad*0.5+1.5*i, dialRad*0.5+1.5*i);
              }
              fill(190);
              strokeWeight(2);
              stroke(200);
              ellipse(dialX, dialY, dialRad*0.5, dialRad*0.5);
              noStroke();
              pushMatrix();
              translate(dialX, dialY);
              rotate(angle);
              fill(100+dicol*40);
              triangle(dialRad*0.5*0.48, 0, dialRad*0.5*0.3, 3, dialRad*0.5*0.3, -3);
              fill(0);
              ellipse(0, 0, 5, 5);
              popMatrix();
            }
        </script>
    <canvas id="sketch" style="border: 1px solid rgb(0, 0, 0);"></canvas>
  </div>
</body>

</html>